# WARNING - Generated by {fusen} from dev/flat_chronicle.Rmd: do not edit by hand

#' Decorates a function to output objects of type `chronicle`.
#' @param .f A function to decorate.
#' @param .g Optional. A function to apply to the intermediary results for monitoring purposes. Defaults to returning NA.
#' @param strict Controls if the decorated function should catch only errors (1), errors and warnings (2, the default) or errors, warnings and messages (3).
#' @param diff Whether to show the diff between the input and the output ("full"), just a summary of the diff ("summary"), or none ("none", the default)
#' @return A function which returns objects of type `chronicle`. `chronicle` objects carry several
#' elements: a `value` which is the result of the function evaluated on its inputs and a second
#' object called `log_df`. `log_df` contains logging information, which can be read using
#' `read_log()`. `log_df` is a data frame with columns: outcome, function, arguments, message, start_time, end_time, run_time, g and diff_obj.
#' @details
#' To chain multiple decorated function, use `bind_record()` or `%>=%`.
#' If the `diff` parameter is set to "full", `diffobj::diffObj()`
#' (or `diffobj::summary(diffobj::diffObj()`, if diff is set to "summary")
#' gets used to provide the diff between the input and the output.
#' This diff can be found in the `log_df` element of the result, and can be
#' viewed using `check_diff()`.
#' @importFrom diffobj diffObj summary
#' @importFrom dplyr mutate lag row_number select
#' @importFrom maybe is_nothing
#' @importFrom rlang enexprs
#' @importFrom tibble tibble
#' @importFrom utils tail
#' @examples
#' record(sqrt)(10)
#' record(sqrt)(x = 10)
#' @export
record <- function(.f, .g = (\(x) NA), strict = 2, diff = "none") {
  fstring <- deparse1(substitute(.f))

  function(..., .log_df = data.frame()) {
    # Capture the call without evaluating arguments to support NSE (e.g., dplyr)
    call <- match.call()
    # Extract arguments from the call object. First element is the function name.
    all_args <- as.list(call[-1])

    # The first argument is our main input value. It needs to be evaluated.
    # The name of the first argument can be specified or not.
    # If not specified, it's just the value. If specified, it's name=value.
    # We need to evaluate it to get the actual value.
    .value <- eval(all_args[[1]], envir = parent.frame())

    # The rest of the arguments are for the decorated function .f
    # We keep them as they are (unevaluated)
    other_args <- all_args[-1]

    # For logging, deparse the other_args to get a string representation
    args_str <- sapply(
      names(other_args),
      function(nm) {
        arg_val_str <- deparse(other_args[[nm]])
        if (nm == "") {
          # unnamed arg
          arg_val_str
        } else {
          # named arg
          paste(nm, "=", arg_val_str)
        }
      }
    )
    args <- paste0(args_str, collapse = ", ")

    start <- Sys.time()
    pure_f <- purely(.f, strict = strict)
    # We pass the evaluated .value and the unevaluated other_args to pure_f
    res_pure <- do.call(pure_f, c(list(.value), other_args))
    end <- Sys.time()

    input <- .value
    output <- maybe::from_maybe(res_pure$value, default = maybe::nothing())
    diff_obj <- switch(
      diff,
      "none" = NULL,
      "summary" = diffobj::summary(diffobj::diffObj(input, output)),
      "full" = diffobj::diffObj(input, output)
    )

    was_successful <- !maybe::is_nothing(res_pure$value)

    log_df_entry <- make_log_df(
      success = as.integer(was_successful),
      fstring = fstring,
      args = args,
      res_pure = res_pure,
      start = start,
      end = end,
      .g = .g,
      diff_obj = diff_obj
    )

    log_df <- dplyr::bind_rows(.log_df, log_df_entry) |>
      dplyr::mutate(
        ops_number = dplyr::row_number(),
        lag_outcome = dplyr::lag(outcome, 1)
      )

    # Correct the message for chained failures
    current_row <- nrow(log_df)
    if (
      !was_successful &&
        current_row > 1 &&
        grepl("NOK!", log_df$lag_outcome[current_row])
    ) {
      log_df$message[current_row] <- "Pipeline failed upstream"
    }

    list(
      value = res_pure$value,
      log_df = log_df
    ) |>
      structure(class = "chronicle")
  }
}


#' Decorate a list of functions
#' @details
#' Functions must be entered as strings of the form "function" or "package::function".
#' The code gets generated and copied into the clipboard. The code can then be pasted
#' into the text editor. On GNU/Linux systems, you might get the following error
#' message on first use: "Error in : Clipboard on X11 requires that the DISPLAY envvar be configured".
#' This is an error message from `clipr::write_clip()`, used by `record_many()` to put
#' the generated code into the system's clipboard.
#' To solve this issue, run `echo $DISPLAY` in the system's shell.
#' This command should return a string like ":0". Take note of this string.
#' In your .Rprofile, put the following command: Sys.setenv(DISPLAY = ":0") and restart
#' the R session. `record_many()` should now work.
#' @param list_funcs A list of function names, as strings.
#' @param .g Optional. Defaults to a function which returns NA.
#' @param strict Controls if the decorated function should catch only errors (1), errors and warnings (2, the default) or errors, warnings and messages (3).
#' @param diff Whether to show the diff between the input and the output ("full"), just a summary of the diff ("summary"), or none ("none", the default)
#' @return Puts a string into the systems clipboard.
#' @importFrom stringr str_remove_all
#' @importFrom clipr write_clip
#' @export
#' @examples
#' \dontrun{
#' list_funcs <- list("exp", "dplyr::select", "exp")
#' record_many(list_funcs)
#' }
record_many <- function(
  list_funcs,
  .g = (function(x) NA),
  strict = 2,
  diff = "none"
) {
  sanitized_list <- stringr::str_remove_all(list_funcs, "(.*?)\\:")

  clipr::write_clip(
    paste0(
      "r_",
      sanitized_list,
      " <- ",
      "record(",
      list_funcs,
      ", .g = ",
      deparse(substitute(.g)),
      ", strict = ",
      strict,
      ", diff = ",
      paste0("\"", diff, "\""),
      ")"
    )
  )

  message(
    "Code copied to clipboard. You can now paste it into your text editor."
  )
}


#' Creates the log_df element of a chronicle object.
#' @param ops_number Tracks the number of the operation in a chain of operations.
#' @param success Did the operation succeed?
#' @param fstring The function call.
#' @param args The arguments of the call.
#' @param res_pure The result of the purely call.
#' @param start Starting time.
#' @param end Ending time.
#' @param .g Optional. A function to apply to the intermediary results for monitoring purposes. Defaults to returning NA.
#' @param diff_obj Optional. Output of the `diff` parameter in `record()`.
#' @importFrom tibble tibble
#' @importFrom maybe from_maybe nothing
#' @return A tibble containing the log.
#' @noRd
make_log_df <- function(
  ops_number = 1,
  success,
  fstring,
  args,
  res_pure,
  start = Sys.time(),
  end = Sys.time(),
  .g = (\(x) NA),
  diff_obj = NULL
) {
  outcome <- ifelse(success == 1, "OK! Success", "NOK! Caution - ERROR")

  tibble::tibble(
    "ops_number" = ops_number,
    "outcome" = outcome,
    "function" = fstring,
    "arguments" = args,
    "message" = paste0(res_pure$log_df, collapse = " "),
    "start_time" = start,
    "end_time" = end,
    "run_time" = end - start,
    "g" = list(.g(maybe::from_maybe(
      res_pure$value,
      default = maybe::nothing()
    ))),
    "diff_obj" = list(diff_obj),
    "lag_outcome" = NA
  )
}

#' Reads the log of a chronicle.
#' @param .c A chronicle object.
#' @return The log of the object.
#' @examples
#' \dontrun{
#' read_log(chronicle_object)
#' }
#' @export
read_log <- function(.c) {
  log_df <- .c$log_df

  make_sentence <- function(i) {
    func_call <- paste0(log_df[i, "function"], "(", log_df[i, "arguments"], ")")
    success_status <- if (grepl("Success", log_df$outcome[i])) {
      "successfully"
    } else {
      paste0("unsuccessfully with following exception: ", log_df$message[i])
    }
    success_symbol <- ifelse(grepl("Success", log_df$outcome[i]), "OK!", "NOK!")

    paste(
      success_symbol,
      func_call,
      "ran",
      success_status,
      "at",
      log_df$start_time[i]
    )
  }

  total_runtime <- sum(log_df$run_time)
  units(total_runtime) <- "secs"

  sentences <- sapply(1:nrow(log_df), make_sentence)

  c("Complete log:", sentences, paste("Total running time:", total_runtime))
}


#' Print method for chronicle objects.
#' @param x A chronicle object.
#' @param ... Unused.
#' @return No return value, called for side effects (printing the object on screen).
#' @details
#' `chronicle` object are, at their core, lists with the following elements:
#' * "$value": a an object of type `maybe` containing the result of the computation (see the "Maybe monad" vignette for more details on `maybe`s).
#' * "$log_df": a `data.frame` object containing the printed object’s log information.
#'
#' `print.chronicle()` prints the object on screen and shows:
#' * the value using its `print()` method (for example, if the value is a data.frame, `print.data.frame()` will be used)
#' * a message indicating to the user how to recuperate the value inside the `chronicle` object and how to read the object’s log
#' @export
print.chronicle <- function(x, ...) {
  if (all(grepl("Success", x$log_df$outcome))) {
    succeed <- "successfully"
    success_symbol <- "OK!"
  } else {
    succeed <- "unsuccessfully"
    success_symbol <- "NOK!"
  }

  cat(paste0(success_symbol, " Value computed ", succeed, ":\n"))
  cat("---------------\n")
  print(x$value, ...)
  cat("\n")
  cat("---------------\n")
  cat("This is an object of type `chronicle`.\n")
  cat("Retrieve the value of this object with unveil(.c, \"value\").\n")
  cat("To read the log of this object, call read_log(.c).\n")
  cat("\n")
}

#' Checks whether an object is of class "chronicle"
#' @param .x An object to test.
#' @export
#' @return TRUE if .x is of class "chronicle", FALSE if not.
is_chronicle <- function(.x) {
  identical(class(.x), "chronicle")
}

#' Coerce an object to a chronicle object.
#' @param .x Any object.
#' @param .log_df Used internally, the user does need to interact with it. Defaults to an empty data frame.
#' @return Returns a chronicle object with the object as the $value.
#' @importFrom tibble tibble
#' @importFrom dplyr bind_rows
#' @importFrom maybe just
#' @examples
#' as_chronicle(3)
#' @export
as_chronicle <- function(.x, .log_df = data.frame()) {
  res_pure <- list("log" = NA, "value" = NA)

  log_df <- make_log_df(
    success = 1,
    fstring = "as_chronicle",
    args = NA,
    res_pure = res_pure,
    start = Sys.time(),
    end = Sys.time()
  )

  list(value = maybe::just(.x), log_df = dplyr::bind_rows(.log_df, log_df)) |>
    structure(class = "chronicle")
}


#' Retrieve an element from a chronicle object.
#' @param .c A chronicle object.
#' @param .e Element of interest to retrieve, one of "value" or "log_df".
#' @return The `value` or `log_df` element of the chronicle object .c.
#' @importFrom maybe from_maybe nothing
#' @examples
#' r_sqrt <- record(sqrt)
#' r_exp <- record(exp)
#' 3 |> r_sqrt() %>=% r_exp() |> unveil("value")
#' @export
unveil <- function(.c, .e) {
  if (!is_chronicle(.c)) {
    stop("`.c` must be a chronicle object.")
  }

  stopifnot(
    '.e must be either "value" or "log_df"' = .e %in% c("value", "log_df")
  )

  if (.e == "value") {
    maybe::from_maybe(.c[[.e]], default = maybe::nothing())
  } else {
    .c[[.e]]
  }
}


#' Check the output of the .g function
#' @details
#' `.g` is an option argument to the `record()` function. Providing this optional
#' function allows you, at each step of a pipeline, to monitor interesting characteristics
#' of the `value` object. See the package's Readme file for an example with data frames.
#' @param .c A chronicle object.
#' @param columns Columns to select for the output. Defaults to c("ops_number", "function").
#' @return A data.frame with the selected columns and column "g".
#' @examples
#' r_subset <- record(subset, .g = dim)
#' result <- r_subset(mtcars, select = am)
#' check_g(result)
#' @export
check_g <- function(.c, columns = c("ops_number", "function")) {
  as.data.frame(.c$log_df[, c(columns, "g")])
}

#' Check the output of the diff column
#' @details
#' `diff` is an option argument to the `record()` function. When `diff` = "full",
#' a diff of the input and output of the decorated function gets saved, and if
#' `diff` = "summary" only a summary of the diff is saved.
#' @param .c A chronicle object.
#' @param columns Columns to select for the output. Defaults to c("ops_number", "function").
#' @return A data.frame with the selected columns and column "diff_obj".
#' @examples
#' r_subset <- record(subset, diff = "full")
#' result <- r_subset(mtcars, select = am)
#' check_diff(result) # <- this is the data frame listing the operations and the accompanying diffs
#' check_diff(result)$diff_obj # <- actually look at the diffs
#' @export
check_diff <- function(.c, columns = c("ops_number", "function")) {
  as.data.frame(.c$log_df[, c(columns, "diff_obj")])
}
