# WARNING - Generated by {fusen} from dev/flat_ggplot.Rmd: do not edit by hand

#' Create a ggplot object to display an error message.
# (This helper function is correct and remains unchanged)
#' @noRd
#' @importFrom ggplot2 ggplot aes annotate theme_void theme element_rect
#' @importFrom stringr str_wrap
create_error_plot <- function(error_message) {
  background_color <- "#FFDDDD"
  error_text <- stringr::str_wrap(error_message, width = 40)

  ggplot2::ggplot() +
    ggplot2::aes(x = 0, y = 0) +
    ggplot2::annotate(
      "text", x = 0, y = 0, label = error_text, color = "black", size = 4
    ) +
    ggplot2::theme_void() +
    ggplot2::theme(
      plot.background = ggplot2::element_rect(fill = background_color, color = NA),
      panel.background = ggplot2::element_rect(fill = background_color, color = NA)
    )
}

#' Record a ggplot expression
#'
#' @description
#' `record_ggplot` captures a complete `{ggplot2}` expression, evaluates it, and
#' creates a `chronicle` object. This function uses a robust `tryCatch` and
#' `withCallingHandlers` pattern to reliably capture errors and modern `rlang`
#' warnings and messages according to the `strict` level.
#'
#' If the expression fails, the log will capture the condition, and the `value` of
#' the chronicle object will be a new ggplot object that visually displays the message.
#'
#' @param ggplot_expression The entire `{ggplot2}` expression to be recorded.
#' @param strict An optional integer argument controlling what is treated as a failure:
#'   * `1`: Catches only errors.
#'   * `2`: Catches errors and warnings (the default).
#'   * `3`: Catches errors, warnings, and messages.
#' @return A `chronicle` object.
#' @importFrom rlang enquo eval_tidy quo_text cnd_message abort
#' @importFrom ggplot2 ggplot_build
#' @export
record_ggplot <- function(ggplot_expression, strict = 2) {

  ggplot_expr_quo <- rlang::enquo(ggplot_expression)
  fstring <- rlang::quo_text(ggplot_expr_quo)
  start <- Sys.time()

  # This is the canonical R pattern for converting non-exiting conditions
  # (warnings, messages) into exiting conditions (errors) so they can be caught.
  res <- tryCatch(
    withCallingHandlers(
      # The main expression to evaluate
      {
        ggplot_obj <- rlang::eval_tidy(ggplot_expr_quo)
        ggplot2::ggplot_build(ggplot_obj) # This line triggers render-time conditions
        ggplot_obj # The successful return value
      },
      # This handler specifically targets the class of warnings from ggplot2/cli.
      rlang_warning = function(w) {
        if (strict >= 2) {
          # Promote the warning to an error to force an exit,
          # chaining the original warning for later inspection.
          rlang::abort("promoted_warning", parent = w)
        }
      },
      # This handler specifically targets messages from ggplot2/cli.
      rlang_message = function(m) {
        if (strict >= 3) {
          # Promote the message to an error.
          rlang::abort("promoted_message", parent = m)
        }
      }
    ),
    # This catches both original errors and our promoted conditions.
    error = function(e) e
  )
  end <- Sys.time()

  was_successful <- !inherits(res, "condition")
  final_value <- NULL
  log_message <- NA

  if (was_successful) {
    final_value <- maybe::just(res)
  } else {
    # If we caught a promoted condition, the REAL condition is the parent.
    original_cnd <- res$parent
    if (!is.null(original_cnd)) {
      log_message <- rlang::cnd_message(original_cnd)
    } else {
      # Otherwise, it was a genuine error.
      log_message <- rlang::cnd_message(res)
    }
    error_plot <- create_error_plot(log_message)
    final_value <- maybe::just(error_plot)
  }

  res_for_log <- list(value = final_value, log_df = log_message)

  log_df <- make_log_df(
    success = as.integer(was_successful),
    fstring = fstring,
    args = "",
    res_pure = res_for_log,
    start = start,
    end = end
  )

  list(
    value = final_value,
    log_df = log_df
  ) |>
  structure(class = "chronicle")
}
